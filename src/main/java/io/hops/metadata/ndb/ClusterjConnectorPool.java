package io.hops.metadata.ndb;

import com.mysql.clusterj.*;
import io.hops.Reconnector;
import io.hops.exception.StorageException;
import io.hops.metadata.ndb.multizone.ConnectionTo;
import io.hops.metadata.ndb.mysqlserver.MysqlServerConnector;
import io.hops.metadata.ndb.wrapper.HopsExceptionWrapper;
import io.hops.metadata.ndb.wrapper.HopsSession;

import java.util.Map;
import java.util.Properties;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * This class holds one clusterj connector per thread, creating it if necessary.
 * It also monitors the connection to the database cluster, and can reconnect if it fails.
 * According to the
 * <a href="https://dev.mysql.com/doc/ndbapi/en/mccj-using-clusterj-start.html">clusterj documentation</a>,
 * there should only be one instance of this class per java virtual machine.
 * "Usually, there is only a single SessionFactory per NDB Cluster, per Java Virtual Machine."
 */
public class ClusterjConnectorPool implements Reconnector {
  static {
    // raise log level for clusterj to WARN
    Logger.getLogger("com.mysql.clusterj").setLevel(Level.WARNING);
  }

  // initialization data
  private final String clusterConnectString;
  private final String databaseName;
  private final Properties conf;
  private final ConnectionTo to;

  // holds the current wrapper
  private HopsExceptionWrapper wrapper;

  // this variable counts the number of re-connections so that we can ignore
  // exceptions from old connectors
  private AtomicInteger age = new AtomicInteger(0);

  private volatile boolean connected;

  /**
   * This class captures exceptions from all connectors generated by the pool
   * and disconnects the pool in case of a critical exception.
   * This class only causes a disconnection if the exception is new.
   * To track which exceptions are new, the outer pool tracks the number of reconnection events (the age).
   * If the age of the wrapper is the same as the age of the pool, the event is new.
   * Otherwise no disconnection is triggered.
   */
  private class DisconnectionWrapper extends HopsExceptionWrapper {
    private final int wrapperAge;

    DisconnectionWrapper(final int wrapperAge) {
      this.wrapperAge = wrapperAge;
    }

    @Override
    public StorageException toStorageException(ClusterJException exc) {
      if (exc instanceof ClusterJDatastoreException && isClusterFailure((ClusterJDatastoreException) exc)) {
        if (ClusterjConnectorPool.this.age.compareAndSet(wrapperAge, wrapperAge + 1)) {
          ClusterjConnectorPool.this.connected = false;
        }
      }
      return super.toStorageException(exc);
    }
  }

  // locks all the session attributes
  private final ReadWriteLock sessionLock = new ReentrantReadWriteLock();
  // provides a way to create new sessions.
  // if this is null, the connection is not active
  private SessionFactory sessionFactory;
  // connector to the mysql cluster
  private MysqlServerConnector mysqlConnector;

  // keeps a per-thread connector
  private ThreadLocal<ClusterjConnector> connectors;


  /**
   * Create an instance of the pool.
   *
   * @param to   database cluster to connect to, a {@link ConnectionTo}
   * @param conf the configuration parameters for this and the mysql local
   * @throws StorageException if the initial connection fails
   */
  public ClusterjConnectorPool(final ConnectionTo to, final Properties conf) throws StorageException {
    this(to, conf, new HopsExceptionWrapper());
  }

  public ClusterjConnectorPool(
      final ConnectionTo to,
      final Properties conf,
      final HopsExceptionWrapper wrapper
  ) throws StorageException {
    this.to = to;
    this.conf = conf;
    this.wrapper = wrapper;

    Properties clusterjConf = clusterjProperties(this.conf);
    this.clusterConnectString = (String) clusterjConf.get(Constants.PROPERTY_CLUSTER_CONNECTSTRING);
    this.databaseName = (String) clusterjConf.get(Constants.PROPERTY_CLUSTER_DATABASE);
    this.connected = false;
    this.reconnect();
  }


  private Properties clusterjProperties(final Properties conf) {
    final String clusterjPrefix = this.to.getConfigPrefix() + ".clusterj";
    Properties res = new Properties();
    // set some reasonable defaults for reconnection properties
    // these will be overwritten below if they are specified in config
    res.put("com.mysql.clusterj.connect.timeout.mgm", 2000); // timeout to the management server
    res.put("com.mysql.clusterj.connect.retries", 0); // no retries
    res.put("com.mysql.clusterj.connect.delay", 0); // no delay between retries

    // read from configuration file
    for (Map.Entry<Object, Object> e : conf.entrySet()) {
      String key = (String) e.getKey();
      if (key.startsWith(clusterjPrefix)) {
        String newKey = "com.mysql.clusterj" + key.substring(clusterjPrefix.length());
        res.put(newKey, e.getValue());
      }
    }

    return res;
  }

  @Override
  public boolean isConnected() {
    return connected;
  }

  @Override
  public void reconnect() throws StorageException {
    if (this.sessionFactory != null) {
      disconnect();
    }

    // we build the factory first, if this fails, leave the object in a connected=false state
    SessionFactory factory;
    try {
      factory = ClusterJHelper.getSessionFactory(clusterjProperties(conf));
      Session s = factory.getSession();
      s.close();
    } catch (ClusterJException exc) {
      // our wrapper may trigger events, we just want to throw an exception here...
      throw new HopsExceptionWrapper().toStorageException(exc);
    }

    // reconnect
    sessionLock.writeLock().lock();
    try {

      this.connected = true;
      // build a new wrapper with the new age.
      // the age can only be incremented once every epoch by the wrapper
      this.wrapper = new DisconnectionWrapper(this.age.get());

      this.mysqlConnector = new MysqlServerConnector(to.getConfigPrefix(), conf);
      this.connectors = new ThreadLocal<>();
      this.sessionFactory = factory;
    } finally {
      sessionLock.writeLock().unlock();
    }
  }

  private void disconnect() {
    sessionLock.writeLock().lock();
    try {
      this.connectors = null; // allow connectors to be gc'ed
      sessionFactory.close();
    } finally {
      sessionLock.writeLock().unlock();
    }
  }

  /**
   * Get the connector associated with the thread.
   * If this is the first invocation or the connector is tainted, a new connector is created.
   *
   * @return the connector
   * @see ClusterjConnector#isTainted()
   */
  public ClusterjConnector getConnector() throws StorageException {
    sessionLock.readLock().lock();
    try {
      if (!this.connected) {
        throw new StorageException(String.format("disconnected from %s database cluster", this.to));
      }
      ClusterjConnector connector = this.connectors.get();
      // if it's tainted, we close it and let the method create a new connector
      if (connector != null && connector.isTainted()) {
        // no need to remove from the pool, as it will be overwritten when a new one is created
        connector.close();
        connector = null;
      }
      // create a connector and cache it for next use
      if (connector == null) {
        connector = new ClusterjConnector(
            this.clusterConnectString,
            this.databaseName,
            new HopsSession(this.sessionFactory.getSession(), this.wrapper),
            this.mysqlConnector
        );
        this.connectors.set(connector);
      }

      return connector;
    } finally {
      sessionLock.readLock().unlock();
    }
  }
}
